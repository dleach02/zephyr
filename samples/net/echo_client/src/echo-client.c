/* echo-client.c - Networking echo client */

/*
 * Copyright (c) 2017 Intel Corporation.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

/*
 * The echo-client application is acting as a client that is run in Zephyr OS,
 * and echo-server is run in the host acting as a server. The client will send
 * either unicast or multicast packets to the server which will reply the packet
 * back to the originator.
 *
 * In this sample application we create four threads that start to send data.
 * This might not be what you want to do in your app so caveat emptor.
 */

#if 1
#define SYS_LOG_DOMAIN "echo-client"
#define NET_SYS_LOG_LEVEL SYS_LOG_LEVEL_DEBUG
#define NET_LOG_ENABLED 1
#endif

#include <zephyr.h>
#include <errno.h>
#include <stdio.h>

#include <net/net_pkt.h>
#include <net/net_core.h>
#include <net/net_context.h>

#include <net/net_app.h>

#if defined(CONFIG_NET_L2_BLUETOOTH)
#include <bluetooth/bluetooth.h>
#include <gatt/ipss.h>
#endif

#if defined(CONFIG_NET_L2_IEEE802154)
#include <ieee802154_settings.h>
#endif

#include "common.h"

#define APP_BANNER "Run echo client"

static void flicker_led_handler(struct k_timer *timer);
K_TIMER_DEFINE(led_timer, &flicker_led_handler, NULL);

static int led_flicker = 0;
static struct device *led_dev;



/* Generated by http://www.lipsum.com/
 * 3 paragraphs, 176 words, 1230 bytes of Lorem Ipsum
 */
const char lorem_ipsum[] =
	"Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
	"Vestibulum id cursus felis, sit amet suscipit velit. Integer "
	"facilisis malesuada porta. Nunc at accumsan mauris. Etiam vehicula, "
	"arcu consequat feugiat venenatis, tellus velit gravida ligula, quis "
	"posuere sem leo eget urna. Curabitur condimentum leo nec orci "
	"mattis, nec faucibus dui rutrum. Ut mollis orci in iaculis "
	"consequat. Nulla volutpat nibh eu velit sagittis, a iaculis dui "
	"aliquam."
	"\n"
	"Quisque interdum consequat eros a eleifend. Fusce dapibus nisl "
	"sit amet velit posuere imperdiet. Quisque accumsan tempor massa "
	"sit amet tincidunt. Integer sollicitudin vehicula tristique. Nulla "
	"sagittis massa turpis, ac ultricies neque posuere eu. Nulla et "
	"imperdiet ex. Etiam venenatis sed lacus tincidunt hendrerit. In "
	"libero nisl, congue id tellus vitae, tincidunt tristique mauris. "
	"Nullam sed porta massa. Sed condimentum sem eu convallis euismod. "
	"Suspendisse lobortis purus faucibus, gravida turpis id, mattis "
	"velit. Maecenas eleifend sapien eu tincidunt lobortis. Sed elementum "
	"sapien id enim laoreet consequat."
	"\n"
	"Aenean et neque aliquam, lobortis lectus in, consequat leo. Sed "
	"quis egestas nulla. Quisque ac risus quis elit mollis finibus. "
	"Phasellus efficitur imperdiet metus."
	"\n";

int ipsum_len = sizeof(lorem_ipsum) - 1;

struct configs conf = {
	.ipv4 = {
		.proto = "IPv4",
	},
	.ipv6 = {
		.proto = "IPv6",
	},
};

static struct k_sem quit_lock;
struct k_sem tcp_ready;

void panic(const char *msg)
{
	if (msg) {
		NET_ERR("%s", msg);
	}

	k_sem_give(&quit_lock);

	for (;;) {
		k_sleep(K_FOREVER);
	}
}

static inline int init_app(void)
{
	NET_INFO(APP_BANNER);

	k_sem_init(&quit_lock, 0, UINT_MAX);

#if defined(CONFIG_NET_L2_BLUETOOTH)
	if (bt_enable(NULL)) {
		NET_ERR("Bluetooth init failed");
		return -EFAULT;
	}
	ipss_init();
	ipss_advertise();
#endif

#if defined(CONFIG_NET_L2_IEEE802154)
	if (ieee802154_sample_setup()) {
		NET_ERR("IEEE 802.15.4 setup failed");
		return -EFAULT;
	}
#endif

	return 0;
}

struct net_pkt *prepare_send_pkt(struct net_app_ctx *ctx,
				 const char *name,
				 int expecting_len)
{
	struct net_pkt *send_pkt;
	bool status;

    led_flicker = 1;

    send_pkt = net_app_get_net_pkt(ctx, AF_UNSPEC, K_FOREVER);

	NET_ASSERT(send_pkt);

	status = net_pkt_append_all(send_pkt, expecting_len, lorem_ipsum,
				    K_FOREVER);
	if (!status) {
		NET_ERR("%s: cannot create send pkt", name);
		net_pkt_unref(send_pkt);
		return NULL;
	}

	return send_pkt;
}

#include <adc.h>
#include <board.h>
#include <device.h>
#include <gpio.h>

#define BUFFER_SIZE 5

#if defined(CONFIG_BOARD_FRDM_K64F)
#define ADC_DEV_NAME    CONFIG_ADC_1_NAME
#define ADC_CHANNEL     14
#elif defined(CONFIG_BOARD_FRDM_KL25Z)
#define ADC_DEV_NAME    CONFIG_ADC_0_NAME
#define ADC_CHANNEL     12
#elif defined(CONFIG_BOARD_FRDM_KW41Z)
#define ADC_DEV_NAME    CONFIG_ADC_0_NAME
#define ADC_CHANNEL     3
#elif defined(CONFIG_BOARD_HEXIWEAR_K64)
#define ADC_DEV_NAME    CONFIG_ADC_0_NAME
#define ADC_CHANNEL     16
#elif defined(CONFIG_BOARD_HEXIWEAR_KW40Z)
#define ADC_DEV_NAME    CONFIG_ADC_0_NAME
#define ADC_CHANNEL     1
#else
#define ADC_DEV_NAME    CONFIG_ADC_0_NAME
#define ADC_CHANNEL     10
#endif
static u16_t seq_buffer[BUFFER_SIZE];

/* Change this if you have an LED connected to a custom port */
#define PORT    LED0_GPIO_PORT
/* Change this if you have an LED connected to a custom pin */
#define LED     LED0_GPIO_PIN

/* 1000 msec = 1 sec */
#define SLEEP_TIME      100


static struct adc_seq_entry entry = {
	.sampling_delay = 30,
	.channel_id = ADC_CHANNEL,
	.buffer = (void *)seq_buffer,
	.buffer_length = BUFFER_SIZE * sizeof(seq_buffer[0])
};

static struct adc_seq_table table = {
	.entries = &entry,
	.num_entries = 1,
};



static void flicker_led_handler(struct k_timer *timer)
{
    if (led_flicker)
    {
        gpio_pin_write(led_dev, LED, 0);
        led_flicker = 0;
    }
    else
    {
        gpio_pin_write(led_dev, LED, 1);
    }
}


void djlzork(void)
{
#if 1
    int i;
	int ret;
	struct device *adc_dev = device_get_binding(ADC_DEV_NAME);

	led_dev = device_get_binding(PORT);
	/* Set LED pin as output */
	gpio_pin_configure(led_dev, LED, GPIO_DIR_OUT);

    gpio_pin_write(led_dev, LED, 0);
    k_sleep(SLEEP_TIME);
    gpio_pin_write(led_dev, LED, 1);
    k_sleep(SLEEP_TIME);
    gpio_pin_write(led_dev, LED, 0);


	if (!adc_dev) {
		SYS_LOG_INF("Cannot get ADC device\n");
		return;
	}

	/* 1. Verify adc_enable() */
	adc_enable(adc_dev);

	k_sleep(500);

	/* 2. Verify adc_read() */
	ret = adc_read(adc_dev, &table);
	if (ret != 0) {
		SYS_LOG_INF("Failed to fetch sample data from ADC controller\n");
		return;
	}

	SYS_LOG_INF("Channel %d ADC Sample: ", ADC_CHANNEL);
	for (i = 0; i < BUFFER_SIZE; i++) {
		SYS_LOG_INF("%d ", seq_buffer[i]);
	}
	SYS_LOG_INF("\n");
    k_sleep(SLEEP_TIME);
    k_sleep(SLEEP_TIME);

	/* 3. Verify adc_disable() */
	//adc_disable(adc_dev);

    //k_timer_start(&led_timer,10,10);
#endif
}


void main(void)
{
	int ret;

	init_app();
    djlzork();

	if (IS_ENABLED(CONFIG_NET_TCP)) {
		if (IS_ENABLED(CONFIG_NET_UDP)) {
			k_sem_init(&tcp_ready, 0, 1);
		}

		ret = start_tcp();
		if (ret < 0) {
			goto quit;
		}

		/* We start the UDP after the TCP is connected properly.
		 * This is done like this so that UDP does not use all the
		 * buffers as it is basically flooding the link with UDP
		 * data.
		 */
		if (IS_ENABLED(CONFIG_NET_UDP)) {
			k_sem_take(&tcp_ready, K_FOREVER);
		}
	}

	if (IS_ENABLED(CONFIG_NET_UDP)) {
		start_udp();
	}

	k_sem_take(&quit_lock, K_FOREVER);

quit:
	NET_INFO("Stopping...");

	if (IS_ENABLED(CONFIG_NET_UDP)) {
		stop_udp();
	}

	if (IS_ENABLED(CONFIG_NET_TCP)) {
		stop_tcp();
	}
}
